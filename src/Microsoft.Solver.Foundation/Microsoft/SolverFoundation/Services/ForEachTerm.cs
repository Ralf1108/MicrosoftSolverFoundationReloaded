using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.SolverFoundation.Common;
using Microsoft.SolverFoundation.Properties;

namespace Microsoft.SolverFoundation.Services
{
	/// <summary>
	/// A term representing iterating over a set to construct a group of values. Unlike most terms, a ForEach
	/// represents multiple values.
	/// </summary>
	internal class ForEachTerm : Term
	{
		/// <summary>
		/// A dummy term representing the iteration variable.
		/// </summary>
		internal readonly Term _iterator;

		/// <summary>
		/// The set of values to iterate over. The actual values don't need to be filled in until data is bound to the model.
		/// </summary>
		internal readonly Set _set;

		/// <summary>
		/// The resulting value, using _iterator as a placeholder which will be replaced with each element of _set after data is bound.
		/// </summary>
		internal readonly Term _valueExpression;

		internal override bool IsModelIndependentTerm => _owningModel == null;

		internal override TermType TermType => TermType.ForEach;

		internal override TermValueClass ValueClass => _valueExpression.ValueClass;

		/// <summary>
		/// Construct a term representing multiple values generated by substituting every element of a set into an expression.
		/// </summary>
		/// <param name="iterator">A dummy term used as a placeholder for each element of the set.</param>
		/// <param name="set">The set of values to iterate over.</param>
		/// <param name="valueExpression">The expression that will be produced for each element of the set, using the iterator as placeholder.</param>
		internal ForEachTerm(IterationTerm iterator, Set set, Term valueExpression)
		{
			_iterator = iterator;
			_set = set;
			_valueExpression = valueExpression;
			_owningModel = valueExpression._owningModel;
			_structure = valueExpression._structure | TermStructure.Multivalue;
		}

		internal override Term Clone(string baseName)
		{
			throw new NotSupportedException(Resources.CannotCloneTerm);
		}

		internal override bool TryEvaluateConstantValue(out Rational value, EvaluationContext context)
		{
			throw new NotImplementedException();
		}

		internal virtual bool TryEvaluateConstantValueList(List<Rational> valueList, EvaluationContext context)
		{
			_set.CreateFixedSet(context);
			if (_set.ValueSet == null)
			{
				return false;
			}
			foreach (Term item in AllValues(context))
			{
				if (!item.TryEvaluateConstantValue(out Rational value, context))
				{
					return false;
				}
				valueList.Add(value);
			}
			return true;
		}

		internal override IEnumerable<Term> AllValues(EvaluationContext context)
		{
			try
			{
				_set.CreateFixedSet(context);
				_set.ValueSet.LockValues();
				try
				{
					using (IEnumerator<object> enumerator = _set.ValueSet.Values.GetEnumerator())
					{
						while (enumerator.MoveNext())
						{
							context.SetValue(value: enumerator.Current, term: _iterator);
							foreach (Term item in _valueExpression.AllValues(context))
							{
								yield return item;
							}
						}
					}
				}
				finally
				{
					_set.ValueSet.UnlockValues();
				}
			}
			finally
			{
				context.ClearValue(_iterator);
			}
		}

		public override string ToString()
		{
			return ToString(null, null);
		}

		/// <summary>Formats the value of the current instance using the specified format.
		/// </summary>
		/// <param name="format">The format to use (or null).</param>
		/// <param name="formatProvider">The provider to use to format the value (or null).</param>
		/// <returns>The value of the current instance in the specified format.</returns>
		/// <remarks>
		/// The "n" format causes the decision names to be printed rather than values.
		/// </remarks>
		public override string ToString(string format, IFormatProvider formatProvider)
		{
			return string.Format(CultureInfo.InvariantCulture, "foreach {0} in {1} ({2})", new object[3]
			{
				_iterator.ToString(format, formatProvider),
				_set,
				_valueExpression.ToString(format, formatProvider)
			});
		}

		internal override Result Visit<Result, Arg>(ITermVisitor<Result, Arg> visitor, Arg arg)
		{
			return visitor.Visit(this, arg);
		}
	}
}

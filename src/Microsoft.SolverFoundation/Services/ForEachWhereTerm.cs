using System;
using System.Collections.Generic;
using System.Globalization;
using Microsoft.SolverFoundation.Common;
using Microsoft.SolverFoundation.Properties;

namespace Microsoft.SolverFoundation.Services
{
	/// <summary>
	/// A term representing iterating over a set to construct a group of values. Unlike most terms, a ForEach
	/// represents multiple values.
	/// </summary>
	internal sealed class ForEachWhereTerm : ForEachTerm
	{
		/// <summary>
		/// The condition, using _iterator as a placeholder which will be replaced with each element of _set after data is bound.
		/// </summary>
		internal readonly Term _condExpression;

		/// <summary>
		/// Construct a term representing multiple values generated by substituting a subset of elements of a set into an expression.
		/// </summary>
		/// <param name="iterator">A dummy term used as a placeholder for each element of the set.</param>
		/// <param name="set">The set of values to iterate over.</param>
		/// <param name="valueExpression">The expression that will be produced for each element of the set, using the iterator as placeholder.</param>
		/// <param name="condExpression">The condition that determines which elements will be produced, using the iterator as placeholder.</param>
		internal ForEachWhereTerm(IterationTerm iterator, Set set, Term valueExpression, Term condExpression)
			: base(iterator, set, valueExpression)
		{
			_condExpression = condExpression;
		}

		internal override IEnumerable<Term> AllValues(EvaluationContext context)
		{
			try
			{
				_set.CreateFixedSet(context);
				_set.ValueSet.LockValues();
				using (IEnumerator<object> enumerator = _set.ValueSet.Values.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						context.SetValue(value: enumerator.Current, term: _iterator);
						if (!_condExpression.TryEvaluateConstantValue(out Rational cond, context))
						{
							throw new ModelClauseException(Resources.ConditionOfForEachIsNotConstant, null, OmlParseExceptionReason.InvalidFilterCondition);
						}
						if (cond == 0)
						{
							continue;
						}
						foreach (Term item in _valueExpression.AllValues(context))
						{
							yield return item;
						}
					}
				}
				_set.ValueSet.UnlockValues();
			}
			finally
			{
				context.ClearValue(_iterator);
			}
		}

		/// <summary>Formats the value of the current instance using the specified format.
		/// </summary>
		/// <param name="format">The format to use (or null).</param>
		/// <param name="formatProvider">The provider to use to format the value (or null).</param>
		/// <returns>The value of the current instance in the specified format.</returns>
		public override string ToString(string format, IFormatProvider formatProvider)
		{
			return string.Format(CultureInfo.InvariantCulture, "foreach {0} in {1} where {3} ({2})", _iterator.ToString(format, formatProvider), _set, _valueExpression.ToString(format, formatProvider), _condExpression.ToString(format, formatProvider));
		}

		/// <summary>Returns a string that represents the current instance.
		/// </summary>
		/// <returns>The value of the current instance in the specified format.</returns>
		public override string ToString()
		{
			return ToString(null, null);
		}

		internal override Result Visit<Result, Arg>(ITermVisitor<Result, Arg> visitor, Arg arg)
		{
			return visitor.Visit(this, arg);
		}
	}
}
